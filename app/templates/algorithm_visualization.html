{% extends "base.html" %}

{% block title %}算法可视化展示{% endblock %}

{% block styles %}
{{ super() }}
<style>
    /* 侧边栏动画优化 */
    #sidebar-container {
        transition: all 0.3s ease-in-out;
        position: relative;
        overflow: visible;
        background: #f8f9fa;
        box-shadow: 2px 0 5px rgba(0,0,0,0.1);
    }

    #sidebar.collapsed {
        margin-left: -100%;
        opacity: 0;
    }

    #toggle-sidebar {
        position: absolute;
        right: -40px;
        top: 20px;
        width: 40px;
        height: 40px;
        border-radius: 0 50% 50% 0;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
    }

    #toggle-sidebar:hover {
        right: -35px;
        width: 45px;
    }

    /* 主内容区域优化 */
    #main-content {
        transition: all 0.3s ease-in-out;
        min-height: calc(100vh - 100px);
    }

    /* 可视化容器样式 */
    #visualization-container {
        position: relative;
        background: #ffffff;
        border-radius: 10px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        min-height: 300px; /* 设置最小高度 */
        min-width: 400px; /* 设置最小宽度 */
        resize: none; /* 禁用默认的浏览器拉伸行为 */
        overflow: hidden;
    }

    /* 拉伸角标样式 */
    #resize-handle {
        position: absolute;
        bottom: 0;
        right: 0;
        width: 20px;
        height: 20px;
        background: #f8f9fa; /* 与输入框背景一致 */
        cursor: se-resize; /* 设置鼠标为拉伸样式 */
        border: 1px solid #dee2e6; /* 与输入框边框一致 */
        border-radius: 4px; /* 与输入框圆角一致 */
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); /* 添加轻微阴影 */
    }

    #resize-handle:hover {
        background: #e9ecef; /* 鼠标悬浮时的背景颜色 */
    }

    /* 参数输入优化 */
    .parameter-group {
        margin: 15px 0;
        padding: 10px;
        background: #fff;
        border-radius: 8px;
        border: 1px solid #dee2e6;
    }

    .parameter-group label {
        font-weight: 500;
        color: #2c3e50;
        font-size: 0.9rem;
    }

    /* 算法选择样式 */
    #algorithm-select {
        background: #e9ecef;
        border: none;
        border-radius: 5px;
        padding: 8px 12px;
    }

    /* 运行动画按钮 */
    #run-algorithm {
        transition: transform 0.2s ease;
        background: #4a90e2;
        border: none;
        padding: 10px;
    }

    #run-algorithm:hover {
        transform: translateY(-2px);
        background: #357abd;
    }

    /* 响应式优化 */
    @media (max-width: 768px) {
        #sidebar-container {
            position: fixed;
            z-index: 1000;
            height: 100vh;
            left: 0;
        }
        #toggle-sidebar {
            display: none;
        }
    }
    /* 新增自定义数据输入样式 */
    .custom-data-group {
        margin-top: 15px;
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
    }
    
    /* 逻辑线条动画效果 */
    .logic-line {
        stroke: #4a90e2;
        stroke-width: 2;
        marker-end: url(#arrowhead);
        stroke-dasharray: 1000;
        stroke-dashoffset: 1000;
        animation: draw 1s linear forwards;
    }

    @keyframes draw {
        to {
            stroke-dashoffset: 0;
        }
    }
   
     /* 算法画布样式 */
    #algorithm-canvas {
        height: 100%;
        width: 100%;
        border: 2px solid #000; /* 设置边框颜色为黑色，宽度为 2px */
        box-shadow: 0 0 3px rgba(0, 0, 0, 0.5); /* 添加阴影效果 */
        border-radius: 2px; /* 可选：让边框有圆角 */
    }

    .module-text {
        font-size: 12px; /* 设置字体大小 */
        fill: #000; /* 设置文本颜色 */
        line-height: 1.2; /* 设置行高 */
        font-family: Arial, sans-serif; /* 设置字体 */
        user-select: none; /* 禁止选中 */
        pointer-events: none; /* 禁止鼠标事件干扰 */
    }

    .draggable-module.selected rect {
        stroke: #4a90e2; /* 选中时的边框颜色 */
        stroke-width: 3; /* 选中时的边框宽度 */
    }

    /* 可选中矩形样式 */
    .selectable-rectangle {
        cursor: pointer;
    }

    .selectable-rectangle.selected {
        stroke: #4a90e2; /* 选中时的边框颜色 */
        stroke-width: 3; /* 选中时的边框宽度 */
    }

    /* 文本矩形样式 */
    .text-rectangle rect {
        fill: #e0e0e0; /* 灰色背景 */
        stroke: #000; /* 黑色边框 */
        stroke-width: 2;
        rx: 8; /* 圆角 */
        ry: 8; /* 圆角 */
    }

    .text-content {
        fill: #000; /* 黑色文字 */
        font-size: 14px;
        font-family: Arial, sans-serif;
        white-space: pre; /* 保留手动换行 */
        pointer-events: none; /* 禁止鼠标事件干扰文本 */
    }
</style>
{% endblock %}

{% block page_content %}
<div class="container-fluid">
    <!-- 算法控制台 -->
    <div id="algorithm-console" class="p-3 bg-light border-bottom">
        <div class="row align-items-center">
            <div class="col-md-3">
                <label class="form-label">算法类型</label>
                <select id="algorithm-select" class="form-select">
                    <option value="sorting">排序算法</option>
                    <option value="hashing">哈希算法</option>
                    <option value="encryption">加密算法</option>
                    <option value="rsa">RSA 算法</option> <!-- 新增 RSA 算法选项 -->
                </select>
            </div>
            <div class="col-md-5" id="algorithm-parameters">
                <!-- 动态生成的参数输入框 -->
            </div>
            <div class="col-md-2">
                <button id="run-algorithm" class="btn btn-success w-100">
                    <i class="bi bi-play-circle me-2"></i>运行算法
                </button>
                <select id="animation-speed" class="form-select mt-2">
                    <option value="300">快速</option>
                    <option value="1000" selected>正常</option>
                    <option value="2000">慢速</option>
                </select>
            </div>
            <div class="col-md-2">
                <div class="data-status-box border rounded p-2">
                    <div id="data-status" style="max-height: 120px; overflow-y: auto">
                        <!-- 数据状态内容 -->
                    </div>
                    <button id="pause-algorithm" class="btn btn-secondary mt-2 w-100">
                        <i class="bi bi-pause"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- 中心展示区域 -->
    <div id="main-content" class="p-4">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h3 class="display-6">算法可视化展示</h3>
            <div id="status-indicator" class="badge bg-primary">准备就绪</div>
        </div>
        <div id="visualization-container" class="border rounded resizable">
            <!-- 可视化画布 -->
            <svg id="algorithm-canvas" style="height: 100%; width: 100%;" viewBox="0 0 1000 500" preserveAspectRatio="xMidYMid meet">
                <!-- 添加边框 -->
                <rect x="0" y="0" width="1000" height="500" fill="none" stroke="#000" stroke-width="2"></rect>
            </svg>
            <!-- 可拉伸角标 -->
            <div id="resize-handle" class="custom-data-group"></div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
document.addEventListener('DOMContentLoaded', function () {
let currentSteps = [];
    let currentStep = 0;
    let isPaused = false;
    let animationInterval;
    let lastModulePosition = null;
    let previousInputData = null; // 用于存储上一次的输入数据
 
    const canvas = document.getElementById('algorithm-canvas');
    let viewBox = { x: 0, y: 0, width: 1000, height: 500 }; // 初始 viewBox

    // 初始化全局模块中心点数据
    const moduleCenters = {};

    // 更新 viewBox
    const updateViewBox = () => {
        canvas.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);
    };

    // 缩放功能
    canvas.addEventListener('wheel', (event) => {
        event.preventDefault();
        const zoomFactor = 1.1;
        const mouseX = event.offsetX / canvas.clientWidth * viewBox.width + viewBox.x;
        const mouseY = event.offsetY / canvas.clientHeight * viewBox.height + viewBox.y;

        if (event.deltaY < 0) {
            // 放大
            viewBox.width /= zoomFactor;
            viewBox.height /= zoomFactor;
        } else {
            // 缩小
            viewBox.width *= zoomFactor;
            viewBox.height *= zoomFactor;
        }

        // 调整 viewBox 的中心
        viewBox.x = mouseX - (mouseX - viewBox.x) * (viewBox.width / (viewBox.width * zoomFactor));
        viewBox.y = mouseY - (mouseY - viewBox.y) * (viewBox.height / (viewBox.height * zoomFactor));

        updateViewBox();
    });

    // 画布拖动功能
    let isDraggingCanvas = false;
    let dragStart = { x: 0, y: 0 };

    canvas.addEventListener('mousedown', (event) => {
        if (event.target.tagName !== 'svg') return; // 如果点击的不是画布，禁止画布拖动

        isDraggingCanvas = true;
        dragStart.x = event.offsetX;
        dragStart.y = event.offsetY;
    });

    canvas.addEventListener('mousemove', (event) => {
        if (!isDraggingCanvas) return;

        const dx = (event.offsetX - dragStart.x) / canvas.clientWidth * viewBox.width;
        const dy = (event.offsetY - dragStart.y) / canvas.clientHeight * viewBox.height;

        viewBox.x -= dx;
        viewBox.y -= dy;

        dragStart.x = event.offsetX;
        dragStart.y = event.offsetY;

        updateViewBox();
    });

    canvas.addEventListener('mouseup', () => {
        isDraggingCanvas = false;
    });

    canvas.addEventListener('mouseleave', () => {
        isDraggingCanvas = false;
    });

    let isDraggingModule = false;
    let selectedModules = [];
    let dragStartX = 0;
    let dragStartY = 0;
    let shiftStartModule = null; // 记录多选的起始模块
    let shiftEndModule = null; // 记录多选的结束模块

    canvas.addEventListener('mousedown', (event) => {
        if (event.target.tagName === 'svg') {
            // 如果点击的是画布，取消所有选中模块
            document.querySelectorAll('.draggable-module.selected').forEach((module) => {
                module.classList.remove('selected');
            });
            selectedModules = [];
            shiftStartModule = null;
            shiftEndModule = null;
        } else if (event.target.parentNode.classList.contains('draggable-module')) {
            const clickedModule = event.target.parentNode;

            if (event.shiftKey) {
                // 按住 Shift 键时，执行多选逻辑
                if (!shiftStartModule) {
                    // 如果没有起始模块，设置当前模块为起始模块
                    shiftStartModule = clickedModule;
                    clickedModule.classList.add('selected');
                    selectedModules = [clickedModule];
                } else {
                    // 如果已经有起始模块，设置当前模块为结束模块
                    shiftEndModule = clickedModule;

                    // 获取所有模块
                    const allModules = Array.from(document.querySelectorAll('.draggable-module'));

                    // 找到起始模块和结束模块的索引
                    const startIndex = allModules.indexOf(shiftStartModule);
                    const endIndex = allModules.indexOf(shiftEndModule);

                    // 确定选中范围
                    const [minIndex, maxIndex] = [startIndex, endIndex].sort((a, b) => a - b);

                    // 选中范围内的所有模块
                    selectedModules = allModules.slice(minIndex, maxIndex + 1);
                    selectedModules.forEach((module) => module.classList.add('selected'));
                }
            } else {
                // 如果没有按住 Shift 键，执行单模块拖动逻辑
                isDraggingModule = true;
                dragStartX = event.offsetX;
                dragStartY = event.offsetY;

                // 如果当前点击的模块未被选中，则只拖动当前模块
                if (!clickedModule.classList.contains('selected')) {
                    document.querySelectorAll('.draggable-module.selected').forEach((module) => {
                        module.classList.remove('selected');
                    });
                    clickedModule.classList.add('selected');
                    selectedModules = [clickedModule];
                }
            }
        }
    });

    canvas.addEventListener('mousemove', (event) => {
        if (!isDraggingModule || selectedModules.length === 0) return;

        const dx = event.offsetX - dragStartX;
        const dy = event.offsetY - dragStartY;

        selectedModules.forEach((module) => {
            const transform = module.getAttribute('transform').match(/translate\(([^,]+),\s*([^)]+)\)/);
            const x = parseFloat(transform[1]) + dx;
            const y = parseFloat(transform[2]) + dy;

            module.setAttribute('transform', `translate(${x}, ${y})`);

            // 更新模块的中心点
            const moduleData = module.__data__;
            if (moduleData) {
                moduleData.centerX = x + moduleData.width / 2;
                moduleData.centerY = y + moduleData.height / 2;

                // 更新逻辑线条位置
                updateLines(moduleData);
            }
        });

        dragStartX = event.offsetX;
        dragStartY = event.offsetY;
    });

    canvas.addEventListener('mouseup', () => {
        isDraggingModule = false;
    });

    // 矩形绘制、拖动和拉伸功能
    let isDrawingRectangle = false;
    let isDraggingRectangle = false;
    let isResizingRectangle = false;
    let selectedRectangle = null;
    let rectangleStart = { x: 0, y: 0 };
    let resizeDirection = null; // 拉伸方向

    canvas.addEventListener('mousedown', (event) => {
        if (event.ctrlKey) {
            // 按住 Ctrl 键时，开始绘制矩形
            isDrawingRectangle = true;
            rectangleStart.x = event.offsetX;
            rectangleStart.y = event.offsetY;

            // 创建矩形
            const rectangle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rectangle.setAttribute('x', rectangleStart.x);
            rectangle.setAttribute('y', rectangleStart.y);
            rectangle.setAttribute('width', 0);
            rectangle.setAttribute('height', 0);
            rectangle.setAttribute('fill', 'none'); // 无填充颜色
            rectangle.setAttribute('stroke', '#000'); // 黑色边框
            rectangle.setAttribute('stroke-width', '2');
            rectangle.setAttribute('class', 'selectable-rectangle');
            canvas.insertBefore(rectangle, canvas.firstChild); // 确保矩形始终位于所有内容下方

            // 创建左上角的小圆形
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', rectangleStart.x);
            circle.setAttribute('cy', rectangleStart.y);
            circle.setAttribute('r', 5); // 圆形半径
            circle.setAttribute('fill', '#4a90e2'); // 圆形颜色
            circle.setAttribute('class', 'rectangle-handle');
            canvas.appendChild(circle); // 确保小圆点位于矩形上方

            // 将矩形和小圆形关联
            rectangle.__handle__ = circle;
            circle.__rectangle__ = rectangle;

            selectedRectangle = rectangle;
        } else if (event.target.classList.contains('rectangle-handle')) {
            // 点击小圆点时，选中并拖动矩形
            selectedRectangle = event.target.__rectangle__;
            selectedRectangle.classList.add('selected');
            isDraggingRectangle = true;
            rectangleStart.x = event.offsetX;
            rectangleStart.y = event.offsetY;
        } else if (event.target.classList.contains('selectable-rectangle') && !isDraggingRectangle) {
            // 点击矩形边框时，选中矩形并准备拉伸
            if (!selectedRectangle) return;
            if (selectedRectangle) {
                selectedRectangle.classList.remove('selected');
            }
            selectedRectangle = event.target;
            selectedRectangle.classList.add('selected');

            const rectX = parseFloat(selectedRectangle.getAttribute('x'));
            const rectY = parseFloat(selectedRectangle.getAttribute('y'));
            const rectWidth = parseFloat(selectedRectangle.getAttribute('width'));
            const rectHeight = parseFloat(selectedRectangle.getAttribute('height'));

            // 判断鼠标是否在矩形边框上
            const offsetX = event.offsetX - rectX;
            const offsetY = event.offsetY - rectY;

            const edgeThreshold = 5; // 边框检测阈值
            if (
                offsetX <= edgeThreshold || // 左边框
                offsetX >= rectWidth - edgeThreshold || // 右边框
                offsetY <= edgeThreshold || // 上边框
                offsetY >= rectHeight - edgeThreshold // 下边框
            ) {
                isResizingRectangle = true;

                // 确定拉伸方向
                resizeDirection = {
                    left: offsetX <= edgeThreshold,
                    right: offsetX >= rectWidth - edgeThreshold,
                    top: offsetY <= edgeThreshold,
                    bottom: offsetY >= rectHeight - edgeThreshold,
                };
            }
        } else {
            // 点击空白处取消选中
            if (selectedRectangle) {
                selectedRectangle.classList.remove('selected');
                selectedRectangle = null;
            }
        }
    });

    canvas.addEventListener('mousemove', (event) => {
        if (isDrawingRectangle) {
            // 更新矩形大小
            const x = Math.min(event.offsetX, rectangleStart.x);
            const y = Math.min(event.offsetY, rectangleStart.y);
            const width = Math.abs(event.offsetX - rectangleStart.x);
            const height = Math.abs(event.offsetY - rectangleStart.y);

            selectedRectangle.setAttribute('x', x);
            selectedRectangle.setAttribute('y', y);
            selectedRectangle.setAttribute('width', width);
            selectedRectangle.setAttribute('height', height);

            // 更新小圆点的位置
            const handle = selectedRectangle.__handle__;
            handle.setAttribute('cx', x);
            handle.setAttribute('cy', y);
        } else if (isDraggingRectangle && selectedRectangle) {
            // 移动矩形
            const dx = event.offsetX - rectangleStart.x;
            const dy = event.offsetY - rectangleStart.y;

            const x = parseFloat(selectedRectangle.getAttribute('x')) + dx;
            const y = parseFloat(selectedRectangle.getAttribute('y')) + dy;

            selectedRectangle.setAttribute('x', x);
            selectedRectangle.setAttribute('y', y);

            // 同步更新小圆点的位置
            const handle = selectedRectangle.__handle__;
            handle.setAttribute('cx', x);
            handle.setAttribute('cy', y);

            rectangleStart.x = event.offsetX;
            rectangleStart.y = event.offsetY;
        } else if (isResizingRectangle && selectedRectangle) {
            // 拉伸矩形
            const rectX = parseFloat(selectedRectangle.getAttribute('x'));
            const rectY = parseFloat(selectedRectangle.getAttribute('y'));
            const rectWidth = parseFloat(selectedRectangle.getAttribute('width'));
            const rectHeight = parseFloat(selectedRectangle.getAttribute('height'));

            let newX = rectX;
            let newY = rectY;
            let newWidth = rectWidth;
            let newHeight = rectHeight;

            if (resizeDirection.left) {
                newX = event.offsetX;
                newWidth = rectX + rectWidth - event.offsetX;
            }
            if (resizeDirection.right) {
                newWidth = event.offsetX - rectX;
            }
            if (resizeDirection.top) {
                newY = event.offsetY;
                newHeight = rectY + rectHeight - event.offsetY;
            }
            if (resizeDirection.bottom) {
                newHeight = event.offsetY - rectY;
            }

            selectedRectangle.setAttribute('x', newX);
            selectedRectangle.setAttribute('y', newY);
            selectedRectangle.setAttribute('width', newWidth);
            selectedRectangle.setAttribute('height', newHeight);

            // 同步更新小圆点的位置
            const handle = selectedRectangle.__handle__;
            handle.setAttribute('cx', newX);
            handle.setAttribute('cy', newY);
        }
    });

    canvas.addEventListener('mouseup', () => {
        isDrawingRectangle = false;
        isDraggingRectangle = false;
        isResizingRectangle = false;
        resizeDirection = null;
    });

    canvas.addEventListener('mouseleave', () => {
        isDrawingRectangle = false;
        isDraggingRectangle = false;
        isResizingRectangle = false;
        resizeDirection = null;
    });

    // 删除选中的矩形
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Delete' && selectedRectangle) {
            canvas.removeChild(selectedRectangle);
            canvas.removeChild(selectedRectangle.__handle__); // 删除关联的小圆形
            selectedRectangle = null;
        }
    });

    canvas.addEventListener('dblclick', (event) => {
        if (event.shiftKey && !selectedRectangle && selectedModules.length === 0) {
            // 创建文本矩形组
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', 'text-rectangle');

            // 设置初始位置（减去默认宽高的一半实现中心定位）
            const x = event.offsetX - 100;
            const y = event.offsetY - 25;
            group.setAttribute('transform', `translate(${x}, ${y})`);

            // 创建矩形背景
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', 200);
            rect.setAttribute('height', 50);
            rect.setAttribute('fill', '#e0e0e0'); // 灰色背景
            rect.setAttribute('stroke', '#000'); // 黑色边框
            rect.setAttribute('stroke-width', '2');
            rect.setAttribute('rx', '8'); // 圆角
            rect.setAttribute('ry', '8'); // 圆角
            group.appendChild(rect);

            // 创建文本元素
            const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textElement.setAttribute('x', 100);
            textElement.setAttribute('y', 25);
            textElement.setAttribute('fill', '#000'); // 黑色文字
            textElement.setAttribute('font-size', '14px');
            textElement.setAttribute('dominant-baseline', 'middle');
            textElement.setAttribute('text-anchor', 'middle');
            textElement.textContent = '双击编辑文本';
            group.appendChild(textElement);

            // 添加到画布
            canvas.appendChild(group);

            // 添加双击事件监听器（直接绑定到group）
            group.addEventListener('dblclick', function (e) {
                e.stopPropagation();

                // 创建编辑模态框
                const modal = document.createElement('div');
                modal.style.position = 'fixed';
                modal.style.left = '50%';
                modal.style.top = '50%';
                modal.style.transform = 'translate(-50%, -50%)';
                modal.style.backgroundColor = 'white';
                modal.style.padding = '20px';
                modal.style.borderRadius = '8px';
                modal.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
                modal.style.zIndex = '1000';

                // 添加文本输入框
                const textarea = document.createElement('textarea');
                textarea.style.width = '300px';
                textarea.style.height = '150px';
                textarea.value = textElement.textContent;
                modal.appendChild(textarea);

                // 添加按钮容器
                const buttonContainer = document.createElement('div');
                buttonContainer.style.display = 'flex';
                buttonContainer.style.justifyContent = 'flex-end';
                buttonContainer.style.marginTop = '10px';

                // 添加保存按钮
                const saveButton = document.createElement('button');
                saveButton.textContent = '保存';
                saveButton.style.padding = '5px 15px';
                saveButton.style.marginLeft = '10px';
                saveButton.style.backgroundColor = '#4a90e2';
                saveButton.style.color = 'white';
                saveButton.style.border = 'none';
                saveButton.style.borderRadius = '4px';
                saveButton.addEventListener('click', () => {
                    // 清空现有的文本内容
                    while (textElement.firstChild) {
                        textElement.removeChild(textElement.firstChild);
                    }

                    // 按行拆分文本并创建 <tspan> 元素
                    const lines = textarea.value.split('\n');
                    const lineHeight = 20; // 每行高度
                    lines.forEach((line, index) => {
                        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                        tspan.setAttribute('x', rect.getAttribute('width') / 2); // 水平居中
                        tspan.setAttribute('dy', index === 0 ? '0' : `${lineHeight}px`); // 垂直偏移
                        tspan.textContent = line;
                        textElement.appendChild(tspan);
                    });

                    // 自动调整矩形大小
                    const longestLine = Math.max(...lines.map((line) => line.length));
                    const newWidth = Math.max(200, longestLine * 8 + 20); // 确保最小宽度为 200
                    const newHeight = Math.max(50, lines.length * lineHeight + 20); // 根据行数调整高度

                    rect.setAttribute('width', newWidth);
                    rect.setAttribute('height', newHeight);

                    // 更新文本位置
                    textElement.setAttribute('x', newWidth / 2); // 水平居中
                    textElement.setAttribute('y', lineHeight); // 第一行的起始位置

                    document.body.removeChild(modal);
                });
                buttonContainer.appendChild(saveButton);

                // 添加取消按钮
                const cancelButton = document.createElement('button');
                cancelButton.textContent = '取消';
                cancelButton.style.padding = '5px 15px';
                cancelButton.style.backgroundColor = '#f0f0f0';
                cancelButton.style.border = 'none';
                cancelButton.style.borderRadius = '4px';
                cancelButton.addEventListener('click', () => {
                    document.body.removeChild(modal);
                });
                buttonContainer.appendChild(cancelButton);

                modal.appendChild(buttonContainer);
                document.body.appendChild(modal);
            });

            // 添加拖动功能
            let isDragging = false;
            let offsetX, offsetY;

            group.addEventListener('mousedown', (e) => {
                isDragging = true;
                const transform = group.getAttribute('transform').match(/translate\(([^,]+),\s*([^)]+)\)/);
                offsetX = e.clientX - parseFloat(transform[1]);
                offsetY = e.clientY - parseFloat(transform[2]);
                e.stopPropagation();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                group.setAttribute('transform', `translate(${e.clientX - offsetX}, ${e.clientY - offsetY})`);
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }
    });

    canvas.addEventListener('mousemove', (event) => {
        if (isDraggingRectangle && selectedRectangle) {
            // 拖动文本矩形
            const dx = event.offsetX - rectangleStart.x;
            const dy = event.offsetY - rectangleStart.y;

            const transform = selectedRectangle.getAttribute('transform').match(/translate\(([^,]+),\s*([^)]+)\)/);
            const x = parseFloat(transform[1]) + dx;
            const y = parseFloat(transform[2]) + dy;

            selectedRectangle.setAttribute('transform', `translate(${x}, ${y})`);

            rectangleStart.x = event.offsetX;
            rectangleStart.y = event.offsetY;
        }
    });

    canvas.addEventListener('mouseup', () => {
        isDraggingRectangle = false;
    });

    // 初始化可视化画布
    const initVisualization = () => {
        canvas.innerHTML = ''; // 清空画布
        lastModulePosition = null; // 重置模块位置
        viewBox = { x: 0, y: 0, width: 1000, height: 500 }; // 重置 viewBox
        updateViewBox()
    };

    // 更新数据状态框
    const updateDataStatus = (message, isStep = false) => {
        const statusBox = document.getElementById('data-status');
        const p = document.createElement('p');
        p.className = isStep ? 'step' : '';
        p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        statusBox.appendChild(p);
        statusBox.scrollTop = statusBox.scrollHeight;
    };

    // 动态生成参数输入框
    const generateParameters = (algorithm) => {
        const parametersContainer = document.getElementById('algorithm-parameters');
        parametersContainer.innerHTML = ''; // 清空参数区域

        if (algorithm === 'sorting') {
            parametersContainer.innerHTML = `
                <div class="custom-data-group">
                    <label for="custom-data" class="form-label">输入数组 (用逗号分隔)</label>
                    <input type="text" id="custom-data" class="form-control" placeholder="例如: 3,1,4,1,5">
                </div>`;
        } else if (algorithm === 'hashing') {
            parametersContainer.innerHTML = `
                <div class="custom-data-group">
                    <label for="custom-data" class="form-label">输入字符串</label>
                    <input type="text" id="custom-data" class="form-control" placeholder="例如: Hello World">
                </div>`;
        } else if (algorithm === 'encryption') {
            parametersContainer.innerHTML = `
                <div class="custom-data-group">
                    <label for="custom-data" class="form-label">输入明文</label>
                    <textarea id="custom-data" class="form-control" rows="2" placeholder="例如: Sample Text"></textarea>
                </div>`;
        } else if (algorithm === 'rsa') {
            parametersContainer.innerHTML = `
                <div class="custom-data-group">
                    <label for="custom-data" class="form-label">输入需要加密的字符串</label>
                    <textarea id="custom-data" class="form-control" rows="2" placeholder="例如: RSA Test Data"></textarea>
                </div>`;
        }
    };

    // 创建模块
    const createModule = (x, y, text, isActive = false, color = '#4a90e2') => {
        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.setAttribute('class', 'draggable-module');
        group.setAttribute('transform', `translate(${x}, ${y})`); // 设置模块的初始位置

        // 动态计算模块大小
        const maxCharsPerLine = 15;
        const lines = text.match(new RegExp(`.{1,${maxCharsPerLine}}`, 'g')) || [];
        const totalLines = lines.length;
        const lineHeight = 16;
        const moduleWidth = Math.max(120, maxCharsPerLine * 8); // 动态宽度
        const moduleHeight = Math.max(60, totalLines * lineHeight + 20); // 动态高度

        // 创建矩形模块
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', '0');
        rect.setAttribute('y', '0');
        rect.setAttribute('width', `${moduleWidth}px`);
        rect.setAttribute('height', `${moduleHeight}px`);
        rect.setAttribute('fill', color); // 使用后端传递的颜色
        rect.setAttribute('stroke', '#000'); // 黑色边框
        rect.setAttribute('stroke-width', '2'); // 边框宽度
        rect.setAttribute('rx', '10'); // 圆角
        rect.setAttribute('ry', '10'); // 圆角
        rect.setAttribute('class', `module ${isActive ? 'active' : ''}`);
        group.appendChild(rect);

        // 创建文本
        const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        textElement.setAttribute('x', `${moduleWidth / 2}px`);
        textElement.setAttribute('y', `${moduleHeight / 2 - (totalLines - 1) * lineHeight / 2}px`);
        textElement.setAttribute('text-anchor', 'middle');
        textElement.setAttribute('dominant-baseline', 'middle');
        textElement.setAttribute('class', 'module-text');

        lines.forEach((line, index) => {
            const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
            tspan.setAttribute('x', `${moduleWidth / 2}px`);
            tspan.setAttribute('dy', index === 0 ? '0' : `${lineHeight}px`);
            tspan.textContent = line;
            textElement.appendChild(tspan);
        });

        group.appendChild(textElement);
        canvas.appendChild(group);

        // 初始化模块数据
        const module = {
            group,
            centerX: x + moduleWidth / 2,
            centerY: y + moduleHeight / 2,
            width: moduleWidth,
            height: moduleHeight,
            lines: [], // 初始化逻辑线条数组
            previousModule: null, // 上一步模块
            nextModule: null, // 下一步模块
        };

        // 将模块数据存储在 DOM 节点上
        group.__data__ = module;

        return module;
    };

    // 更新模块的逻辑线条
    const updateLines = (module) => {
        module.lines.forEach(({ line, isStart }) => {
            if (isStart) {
                line.setAttribute('x1', module.centerX);
                line.setAttribute('y1', module.centerY);
            } else {
                line.setAttribute('x2', module.centerX);
                line.setAttribute('y2', module.centerY);
            }
        });
    };

    // 创建逻辑线条
    const createLine = (x1, y1, x2, y2, fromModule, toModule) => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('class', 'logic-line');

        // 将逻辑线条添加到 canvas 的最前面，确保它位于所有模块的下方
        canvas.insertBefore(line, canvas.firstChild);

        // 将逻辑线条与模块关联
        fromModule.lines.push({ line, isStart: true });
        toModule.lines.push({ line, isStart: false });

        // 设置模块的前后关系
        fromModule.nextModule = toModule;
        toModule.previousModule = fromModule;

        // 实时更新线条位置
        updateLines(fromModule);
        updateLines(toModule);
    };

    // 执行步骤
    const executeSteps = () => {
        if (currentStep >= currentSteps.length) {
            document.getElementById('status-indicator').className = 'badge bg-success';
            document.getElementById('status-indicator').textContent = '执行完成';
            return;
        }

        const step = currentSteps[currentStep];
        const totalSteps = currentSteps.length;

        // 基础位置参数
        const baseX = 100;
        const baseY = 100;
        const rowHeight = 120;
        const colWidth = 200;

        // 计算模块位置
        let x = baseX + Math.floor(currentStep / 3) * colWidth;
        let y = baseY + (currentStep % 3) * rowHeight;

        // 处理特殊位置要求
        if (step.position === 'left') {
            x -= 80; // 向左偏移
        } else if (step.position === 'right') {
            x += 80; // 向右偏移
        }

        // 对于并排显示的步骤，调整 y 坐标使其对齐
        if (currentStep > 0 && currentSteps[currentStep - 1].position) {
            y = lastModulePosition.centerY; // 保持与前一个模块相同的 y 坐标
        }

        // 创建模块
        const currentModule = createModule(x, y, `${step.action}\n${step.data}`, true, step.color);

        // 连接逻辑
        if (lastModulePosition) {
            // 对于并排显示的模块，连接到它们共同的父模块
            if (step.position) {
                const parentStepIndex = currentSteps.findIndex(
                    (s, index) => !s.position && index < currentStep
                );
                if (parentStepIndex !== -1) {
                    const parentModule = moduleCenters[parentStepIndex];
                    createLine(
                        parentModule.centerX,
                        parentModule.centerY,
                        currentModule.centerX,
                        currentModule.centerY,
                        parentModule,
                        currentModule
                    );
                }
            } else {
                // 普通情况连接到上一个模块
                createLine(
                    lastModulePosition.centerX,
                    lastModulePosition.centerY,
                    currentModule.centerX,
                    currentModule.centerY,
                    lastModulePosition,
                    currentModule
                );
            }
        }

        // 更新上一个模块的位置
        lastModulePosition = currentModule;
        moduleCenters[currentStep] = currentModule; // 存储模块中心位置

        currentStep++;

        if (!isPaused) {
            const animationSpeed = parseInt(document.getElementById('animation-speed').value, 10);
            animationInterval = setTimeout(executeSteps, animationSpeed);
        }
    };

    // 生成算法步骤
    const generateAlgorithmSteps = (algorithm) => {
        const customData = document.getElementById('custom-data')?.value || '无数据';
        const baseSteps = {
            sorting: [
                { action: "读取输入", data: customData },
                { action: "解析数字", data: customData.split(',') },
                { action: "初始化排序", data: "开始排序流程" },
                { action: "完成排序", data: "最终结果" }
            ],
            hashing: [
                { action: "输入处理", data: customData },
                { action: "编码转换", data: "UTF-8编码" },
                { action: "分块处理", data: "512位块" },
                { action: "完成哈希", data: "最终摘要" }
            ],
            rsa: [
                { action: "生成大素数 p 和 q", data: "随机生成两个大素数 p 和 q" },
                { action: "生成的素数 p", data: "展示生成的 p 值" },
                { action: "生成的素数 q", data: "展示生成的 q 值" },
                { action: "计算 n = p * q", data: "n 是模数，用于公钥和私钥" },
                { action: "计算结果 n", data: "展示计算结果 n" },
                { action: "计算欧拉函数 φ(n)", data: "φ(n) = (p-1) * (q-1)" },
                { action: "计算结果 φ(n)", data: "展示计算结果 φ(n)" },
                { action: "选择公钥指数 e", data: "e 必须与 φ(n) 互质" },
                { action: "选择的公钥指数 e", data: "展示选择的 e 值" },
                { action: "计算私钥 d", data: "d 是 e 关于 φ(n) 的模反元素" },
                { action: "计算结果 d", data: "展示计算结果 d" },
                { action: "导出公钥", data: "展示公钥 (e, n)" },
                { action: "导出私钥", data: "展示私钥 (d, n)" },
                { action: "准备加密数据", data: `待加密数据: ${customData}` },
                { action: "加密完成", data: "展示加密后的数据" },
                { action: "准备解密数据", data: "展示加密后的数据" },
                { action: "解密完成", data: `解密后的数据: ${customData}` }
            ]
        };
        return baseSteps[algorithm] || [];
    };

    // 初始化时创建自定义数据模块
    const initCustomData = () => {
        const customData = document.getElementById('custom-data')?.value || '无数据';
        createModule(50, 50, `原始数据:\n${customData}`);
    };

    // 修改运行按钮事件
    document.getElementById('run-algorithm').addEventListener('click', () => {
        const algorithm = document.getElementById('algorithm-select').value;
        const customData = document.getElementById('custom-data').value;

        // 检测输入数据是否发生变化
        if (customData !== previousInputData) {
            // 如果数据发生变化，先反馈当前数据
            updateDataStatus(`检测到输入数据变动: ${customData}`, false);
            previousInputData = customData; // 更新存储的输入数据
        }

        fetch('/api/algorithm', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                algorithm: algorithm,
                custom_data: customData,
            }),
        })
            .then((response) => response.json())
            .then((data) => {
                if (data.error) {
                    alert(data.error);
                    return;
                }

                currentSteps = data.steps; // 使用后端返回的步骤数据
                currentStep = 0;
                isPaused = false;
                initVisualization();
                executeSteps();
            })
            .catch((error) => {
                console.error('Error:', error);
            });
    });

    // 初始化算法参数输入框
    document.getElementById('algorithm-select').addEventListener('change', function () {
        generateParameters(this.value);
    });

    // 初始化默认参数输入框
    generateParameters(document.getElementById('algorithm-select').value);

    const container = document.getElementById('visualization-container');
    const resizeHandle = document.getElementById('resize-handle');

    let isResizing = false;
    let startX, startY, startWidth, startHeight;

    // 开始调整大小
    resizeHandle.addEventListener('mousedown', (event) => {
        isResizing = true;
        startX = event.clientX;
        startY = event.clientY;
        startWidth = container.offsetWidth;
        startHeight = container.offsetHeight;
        document.body.style.cursor = 'se-resize'; // 设置鼠标样式
        event.preventDefault();
    });

    // 调整大小过程中
    document.addEventListener('mousemove', (event) => {
        if (!isResizing) return;

        const dx = event.clientX - startX;
        const dy = event.clientY - startY;

        // 更新容器大小
        const newWidth = Math.max(startWidth + dx, 400); // 最小宽度 400px
        const newHeight = Math.max(startHeight + dy, 300); // 最小高度 300px

        container.style.width = `${newWidth}px`;
        container.style.height = `${newHeight}px`;

        // 更新 SVG 画布的视图
        const viewBox = canvas.getAttribute('viewBox').split(' ').map(Number);
        viewBox[2] = newWidth; // 更新宽度
        viewBox[3] = newHeight; // 更新高度
        canvas.setAttribute('viewBox', viewBox.join(' '));
    });

    // 停止调整大小
    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            document.body.style.cursor = ''; // 恢复鼠标样式
        }
    });
});
</script>
{% endblock %}